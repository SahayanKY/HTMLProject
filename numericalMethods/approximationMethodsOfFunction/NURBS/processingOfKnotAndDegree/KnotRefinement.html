<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ノットを複数同時に挿入するアルゴリズム</title>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  "HTML-CSS": {
    styles: {".MathJax_Preview": {visibility: "hidden"}}
  },
  tex2jax: {inlineMath: [["\\(","\\)"]]},
  TeX: {extensions: ["AMSmath.js","AMSsymbols.js","http://sonoisa.github.io/xyjax_ext/xypic.js"]}
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
</head>
<body>
\(
\newcommand{\bm}[1]{\boldsymbol{#1}}
\newcommand{\d}{{\rm d}}
\newcommand{\div}{\nabla\cdot}
\newcommand{\grad}{\nabla}
\newcommand{\e}[1]{\bm{e}_{#1}}
\newcommand{\pard}[3]{\frac{\partial^{#2} #3}{\partial #1^{#2}}}
\newcommand{\T}{^{\rm T}}
\newcommand{\l}{&lt;}
\newcommand{\g}{&gt;}
%
\newcommand{\ki}[1]{\langle#1\rangle}
\newcommand{\iki}[1]{\langle\!\!\!\>\langle#1\rangle\!\!\!\>\rangle}
\)
<p>
前回は、ノットを1つだけ挿入することを考えた。しかし、実際にはノットを同時に複数挿入したいことが
ある。そこで今回はそのアルゴリズムについて考えていく。

<p>
基本的な数学的な知識はすでに足りている。本質的には1つだけ挿入する時の処理を逐次行っているだけ
なのである。しかし、これでは無駄な処理が多く、これを省こうとするとややこしい処理をしなければ
ならない。今回は1つ例を挙げ、それを元に考えていく。

<p>
2次のBスプライン曲線の場合を考える。
\(T\)を元のノットベクトル、\(X\)を追加するノットの列、\(\bar{T}\)を追加後のノットベクトルとする。
これらを次のようにおく。\(T\)が単調増加列なのは当然だが、\(X\)も単調増加となるように並べておく。
\begin{align}
	T
&=
	\left\{
		t_0,t_1,\cdots,t_{11}
	\right\} \\
&=
	\left\{
		0,0,0,2,2,4,5,8,9,10,10,10
	\right\} \\
%
%
	X
&=
	\left\{
		x_0,x_1,\cdots,x_4
	\right\} \\
&=
	\left\{
		1,1,3,4,9
	\right\} \\
%
%
	\bar{T}
&=
	\left\{
		\bar{t}_0,\bar{t}_1,\cdots,\bar{t}_{16}
	\right\} \\
&=
	\left\{
		0,0,0,1,1,2,2,3,4,4,5,8,9,9,10,10,10
	\right\}
\end{align}
また、元のコントロールポイントを\(\bm{P}_{i}(i=0,1,\cdots,8)\)とする。そして、このあと
\(x_0\)から順にノットを挿入していくのだが、\(x_j\)挿入後に得られるコントロール
ポイントを\(\bm{Q}_{i}^{j}(i=0,1,\cdots,9+j)\)とする。
（ノットを1つ挿入する度にポイントの数は1つだけ増える）

<p>
さて、まずは1つ目の新しいノット\(x_0=1\)を挿入する時を考える。
このとき、\(t_{k}\leq x_0\l t_{k+1}\)を満たす\(k\)は2である。なので、ポイントの計算式は
次のようになる。
\begin{align}
	\bm{Q}_{i}^0
&=
	\left\{
	\begin{array}{ll}
		\bm{P}_i
		&
			(0\leq i\leq k-p) \\
	%
		\frac{\iki{k+1} -\iki{i}}{\iki{i+p+1} -\iki{i}} \bm{P}_i
		+
		\frac{\iki{i+p+1} -\iki{k+1}}{\iki{i+p+1} -\iki{i}} \bm{P}_{i-1}
		&
			(k-p+1\leq i\leq k) \\
	%
		\bm{P}_{i-1}
	\end{array}
	\right. \\
%
%
&=
	\left\{
	\begin{array}{ll}
		\bm{P}_i
		&
			(0\leq i\leq 0) \\
	%
		\alpha \bm{P}_i +(1-\alpha) \bm{P}_{i-1}
		&
			(1\leq i\leq 2) \\
	%
		\bm{P}_{i-1}
		&
			(3\leq i\leq 9)
	\end{array}
	\right.
\end{align}
ここで、\(\iki{i}\)は\(x_0\)挿入後のノットベクトルのノットで、\(i\)はそのインデックスである。
（前ページと同じ意味）重要なのは、新しいポイント\(\bm{Q}_i^0\)の計算過程を次の図のように表すことだ。
（以降、\(k_i\)を\(x_i\)挿入時の\(k\)の値とする）
<div align="center">
<img src="../image/KnotRefinement_x0Inserted.png"
 alt="x0挿入時のコントロールポイント計算の様子"
 title="x0挿入時のコントロールポイント計算の様子"
 width="100%"
 height="100%">
</div>
ここで、細い黒矢印は代入を、太い白矢印は2本で内分計算（\(\alpha\bm{P}_i+(1-\alpha)\bm{P}_{i-1}\)）を
意味している。

<p>
さて、ここにさらに\(x_1,x_2,\cdots\)と挿入していく。すると、この図は次のようになる。
<div align="center">
<img src="../image/KnotRefinement_AllKnotInserted.png"
 alt="x0からx4までを挿入した時のコントロールポイント計算の様子"
 title="x0からx4までを挿入した時のコントロールポイント計算の様子"
 width="100%"
 height="100%">
</div>
この図や元のポイント計算式から次のことが読み取れる。
<ol>
	<li>\(x_j\)挿入時の内分計算は\(Q_{k-p+1}^{j}\)から\(Q_{k}^{j}\)に対して行われる</li>
	<li>内分計算の前後の代入操作はかなり量が多く、これを省くことで計算時間の短縮化が狙える</li>
</ol>
内分計算の前の代入操作については、\(Q_{i}^{j}\)を計算するときに\(Q_{i}^{j-1}\)の配列上で
計算すれば自然と解決されるのでここでは深く考えない。問題は内分計算の後の代入操作についてだ。

<p>
ここで、思い切って内分計算後の代入操作をカットしてしまうことを考える。
つまり、次の図のように、各ノット挿入時に必要な分だけ元のポイントを代入する（赤字の部分）
ということを考える。
<div align="center">
<img src="../image/KnotRefinement_AllKnotInsertedOmitedSubstitution.png"
 alt="x0からx4までを挿入した時のコントロールポイント計算で不要な代入処理を省略した様子"
 title="x0からx4までを挿入した時のコントロールポイント計算で不要な代入処理を省略した様子"
 width="100%"
 height="100%">
</div>
さて、ここで問題になるのは、どの位置（\(Q_{i}^{j}\)）にどの元のポイント（\(P_i\)）を代入すれば
いいのか、1回のノット挿入でいくつ代入すればいいのか、ということである。その規則性を見いださなければ
アルゴリズムに落とし込めない。

<p>
一見して不規則に見えるが、実は規則性はある。
\(x_i(i\geq 1)\)を挿入する時は\(Q_{k_{i-1}+1}^{i-1}\)～\(Q_{k_i}^{i-1}\)にそれぞれ元のポイント
\(P_{k_{i-1}+1-i}\)～\(P_{k_i -i}\)を代入することになる。
例えば、\(x_2\)を挿入する時は、\(Q_{k_1 +1}^1\)～\(Q_{k_2}^1\)、即ち、\(Q_4^1\)～\(Q_6^1\)の
それぞれに\(P_{k_1 +1-2}\)～\(P_{k_2 -2}\)、即ち、\(P_2\)～\(P_4\)を代入することになる。
また、\(k_{-1}=-1\)とおけば、\(i=0\)の時でもおよそうまくいっていることがわかる。

<p>
さて、ポイントの代入の仕方が分かったところで実際のアルゴリズムについてみていく。
これまでは分かり易いように複数の配列（\(Q_{i}^{0},Q_{i}^{1},\cdots\)）を使って計算してきていたが、
実際にはメモリの消費を抑えるために一つの配列上で計算を行いたい。その点に注意して次の
フローチャートを見て欲しい。













</body>
</html>